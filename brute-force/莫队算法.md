##莫队算法
>处理静态区间查询问题,离线处理，分块暴力;O(n^1.5)
要求能O(1)的从[l,r]转移到[l,r+1],[l,r-1],[l+1,r],[l-1,r];
```c
/*
查询区间内有多少子区间的异或为k
*/
#include<cstdio>
#include<cmath>
#include<stdlib.h>
#include<map>
#include<set>
#include<time.h>
#include<vector>
#include<stack>
#include<queue>
#include<string>
#include<string.h>
#include<iostream>
#include<algorithm>
using namespace std;
#define eps 1e-8
int siz;
struct query
{
    int id;
    int l,r;
}q[100005];
bool cmp(query a,query b)
{
    if(a.l/siz==b.l/siz)return a.r<b.r;
    return a.l/siz<b.l/siz;
}
int pre[100005];
long long num[1<<20];
long long ans[100005];
void solve(int m,int k)
{
    long long cnt=0;
    int l=1,r=0;
    num[0]++;
    for(int i=0;i<m;i++)
    {
        while(r<q[i].r)
        {
            r++;
            cnt+=num[k^(pre[r])];
            num[pre[r]]++;
        }
        while(l>q[i].l)
        {
            l--;
            cnt+=num[k^(pre[l-1])];
            num[pre[l-1]]++;
        }
        while(r>q[i].r)
        {
            num[pre[r]]--;
            cnt-=num[k^(pre[r])];
            r--;
        }
        while(l<q[i].l)
        {
            num[pre[l-1]]--;
            cnt-=num[k^(pre[l-1])];
            l++;
        }
        ans[q[i].id]=cnt;
    }
}
int n,m,k;
int main()
{
    scanf("%d%d%d",&n,&m,&k);
    siz=(int)sqrt(n);
    for(int i=1;i<=n;i++)scanf("%d",&pre[i]);
    for(int i=1;i<=n;i++)pre[i]^=pre[i-1];
    for(int i=0;i<m;i++)
    {
        scanf("%d%d",&q[i].l,&q[i].r);
        q[i].id=i;
    }
    sort(q,q+m,cmp);
    solve(m,k);
    for(int i=0;i<m;i++)
        printf("%I64d\n",ans[i]);
    return 0;
}

```
