#数据结构
##RMQ(区间最值)
```c
int h[100005];
int dp[100005][20];
void init()
{
    for(int i=0; i<20; i++)
        for(int j=0; j<n; j++)
        {
            if(i==0)
                dp[j][i]=h[j];
            else
            if(j+(1<<i)-1<n)
            {
                dp[j][i]=max(dp[j][i-1],dp[j+(1<<(i-1))][i-1]);
            }
        }
}
int query(int l,int r)
{
    double len=(double)r-l+1;
    int two=(int)(log10(len)/log10(2.0));
    return max(dp[l][two],dp[r-(1<<two)+1][two]);
}
```
##Convex hull trick
>Convex hull trick是一种算法或者说数据结构，用于在一组线性函数（形如y=ki*x+bi）中，每次查询给以具体的x，可以快速求出最大/最小的y。

```c
/*
使用该算法的注意事项:单独处理形如y=c的常函数,要先对所有直线按斜率排序.
代码里是求最大值.
*/
#include<cstdio>
#include<cmath>
#include<stdlib.h>
#include<map>
#include<set>
#include<time.h>
#include<vector>
#include<stack>
#include<queue>
#include<string>
#include<string.h>
#include<iostream>
#include<algorithm>
using namespace std;
#define eps 1e-8
struct line
{
    long long k,b;
    line(){}
    line(long long K,long long B)
    {
        k=K;
        b=B;
    }
    long long get(long long x)
    {
        return k*x+b;
    }
};
struct Convex_Hull
{
    int siz;
    line L[200005];
    void init()
    {
        siz=0;
    }
    bool is_bad(int one,int two,int three)//目前凸包集为xxx12,要将3插入,判断是否删除2
    {
        line l1=L[one],l2=L[two],l3=L[three];
        return (l2.b-l1.b)*(l1.k-l3.k)>=(l3.b-l1.b)*(l1.k-l2.k);//我这样肯定可以！
    }
    void insert(line l)
    {
        L[siz++]=l;
        while(siz>=3&&is_bad(siz-3,siz-2,siz-1))
        {
            L[siz-2]=L[siz-1];
            siz--;
        }
    }
    long long query(long long x)//查询横坐标为x的最大值
    {
        int l=0,r=siz-1;
        while(l<r)
        {
            int mid=(l+r)/2;
            if(L[mid].get(x)<=L[mid+1].get(x))
                l=mid+1;
            else
                r=mid;
        }
        return L[l].get(x);
    }
};
Convex_Hull cv;
int n;
long long a[200005];
long long sum[200005];
int main()
{
    scanf("%d",&n);
    long long ans=0;
    long long dans=0;
    for(int i=1;i<=n;i++)
    {
        scanf("%I64d",&a[i]);
        sum[i]=sum[i-1]+a[i];
        ans=ans+a[i]*i;
    }
    cv.init();
    for(int i=2;i<=n;i++)
    {
        cv.insert(line(i-1,-sum[i-2]));
        dans=max(dans,cv.query(a[i])-a[i]*i+sum[i-1]);
    }
    cv.init();
    for(int i=n-1;i>=1;i--)
    {
        cv.insert(line(-(i+1),-sum[i+1]));
        dans=max(dans,cv.query(-a[i])+sum[i]-a[i]*i);
    }
    printf("%I64d\n",ans+dans);
    return 0;
}
```
##树状数组
```c
int a[maxn][maxn];
int n,m;
int lowbit(int x)
{
    return x&(-x);
}
void add(int x,int y,int inf)
{
    for(int i=x;i<=n;i+=lowbit(i))
        for(int j=y;j<=m;j+=lowbit(j))
        a[i][j]+=inf;
}
int sum(int x,int y)
{
    int ans=0;
    for(int i=x;i>0;i-=lowbit(i))
        for(int j=y;j>0;j-=lowbit(j))
        ans+=a[i][j];
    return ans;
}
```
